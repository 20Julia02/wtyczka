# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PyQGISDialog
                                 A QGIS plugin
 This plugin gives diffrence between points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by SH,JB
        email                : Votum1103@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import Qt
from qgis.PyQt import uic, QtWidgets
from qgis.core import Qgis, QgsFeature, QgsGeometry, QgsVectorLayer, QgsProject, QgsPointXY, QgsField, QgsFields, QgsMapLayerModel
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
from qgis.gui import QgsMapCanvas
from PyQt5.QtWidgets import QButtonGroup
from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView
from PyQt5.QtGui import QPixmap


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'PyQGIS_dialog_base.ui'))


class PyQGISDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        super(PyQGISDialog, self).__init__(parent)
        self.setupUi(self)

        final_area = None

        filters = ['Pliki tekstowe (*.txt)', 'Pliki CSV (*.csv)']
        filter_string = ';;'.join(filters)
        self.sciezka.setFilter(filter_string)

        self.checkBox_poligon.setHidden(True)
        self.groupBox_choose_zone.setHidden(True)
        self.label.setVisible(False)
        
        self.button_group = QtWidgets.QButtonGroup()
        self.button_group.addButton(self.height_radioButton)
        self.button_group.addButton(self.area_radioButton)
        self.comboBox_jednostki.setHidden(True)

        self.buttonbox_group = QButtonGroup()
        self.buttonbox_group.addButton(self.checkBox_zone_5)
        self.buttonbox_group.addButton(self.checkBox_zone_6)
        self.buttonbox_group.addButton(self.checkBox_zone_7)
        self.buttonbox_group.addButton(self.checkBox_zone_8)

        self.height_radioButton.toggled.connect(self.on_radio_button_height_toggled)
        self.area_radioButton.toggled.connect(self.on_radio_button_area_toggled)
        self.calculate_Button.clicked.connect(self.on_calculate_button_clicked)
        self.pushButton_add_layer.clicked.connect(self.add_layer_with_coordinates_from_file)
        self.radioButton_2000.toggled.connect(self.setHiddenFalse)
        self.radioButton_1992.toggled.connect(self.setHiddenTrue)
        self.pushButton_clear.clicked.connect(self.claer)

    def display_message(self, message):
        iface.messageBar().pushMessage("Informacja", message, level=Qgis.Info)

    def on_radio_button_height_toggled(self):
        if self.height_radioButton.isChecked():
            self.area_radioButton.setChecked(False)
            self.checkBox_poligon.setHidden(True) 
            self.checkBox_poligon.setChecked(False)
            self.comboBox_jednostki.setHidden(True)
            self.result_label.setText("")
            

    def on_radio_button_area_toggled(self):
        if self.area_radioButton.isChecked():
            self.height_radioButton.setChecked(False)
            self.checkBox_poligon.setEnabled(True)
            self.checkBox_poligon.setHidden(False)
            self.comboBox_jednostki.setHidden(False)
            self.result_label.setText("")

    def on_calculate_button_clicked(self):
        if self.height_radioButton.isChecked():
            self.get_height_between_two_points()
        elif self.area_radioButton.isChecked():
            self.get_area_between_points()
            if self.checkBox_poligon.isChecked():
                self.creating_polygon()

    def get_height_between_two_points(self):
        layer = self.layer_MapLayer.currentLayer()
        selected_features = layer.selectedFeatures()
        if len(selected_features) == 2:
            list_with_height = []
            features_id = []

            for feature in selected_features:
                point_attributes = feature.attributes()
                attribute_value = point_attributes[2]
                feature_id = feature.id()
                features_id.append(feature_id)
                list_with_height.append(attribute_value)

            height_difference = abs(list_with_height[1] - list_with_height[0])
            self.result_label.setText(str(height_difference)+" m")
            self.errors_label.setText("")
            self.display_message(f"Różnica wysokości między punktami o numerach {features_id[0]},{features_id[1]} wynosi: {height_difference} [m]")
        else:
            self.errors_label.setText("Niepoprawna ilość wybranych punktów. Wybierz 2 punkty.")
            self.result_label.setText("")
            
    def get_area_between_points(self):
        layer_area = self.layer_MapLayer.currentLayer()
        selected_features_area = layer_area.selectedFeatures()
        if len(selected_features_area) >= 3:
            list_xy_coordinates = []
            area_features_id = []

            for feature in selected_features_area:
                point_attributes = feature.attributes()
                x_coordinate = point_attributes[0]
                y_coordinate = point_attributes[1]
                feature_id = feature.id()
                area_features_id.append(feature_id)
                list_xy_coordinates.append([x_coordinate, y_coordinate])

            results = []

            for number in range(1, len(list_xy_coordinates) + 1):
                if number == len(list_xy_coordinates):
                    prepared_x = list_xy_coordinates[0][0] + list_xy_coordinates[-1][0]
                    prepared_y = list_xy_coordinates[0][1] - list_xy_coordinates[-1][1]
                    result = prepared_x * prepared_y
                    results.append(result)
                else:
                    prepared_x = list_xy_coordinates[number][0] + list_xy_coordinates[number - 1][0]
                    prepared_y = list_xy_coordinates[number][1] - list_xy_coordinates[number - 1][1]
                    result = prepared_x * prepared_y
                    results.append(result)
            if self.comboBox_jednostki.currentText() == "m2":
                final_area = abs(sum(results) / 2)
            elif self.comboBox_jednostki.currentText() == "a":
                final_area = abs(sum(results) / 2)/100
            elif self.comboBox_jednostki.currentText() == "ha":
                final_area = abs(sum(results) / 2)/10000

            result_area = f"{final_area:.3f}"
            self.result_label.setText(str(result_area))
            self.errors_label.setText("")
            self.final_area = final_area
            self.display_message(f"Pole powierzchni figury o wierzchołkach w punktach o numerach: {area_features_id} wynosi: {final_area} {self.comboBox_jednostki.currentText()}")
        else:
            error = "Niepoprawna ilość wybranych punktów. Wybierz więcej niż 2 punkty"
            self.errors_label.setText(str(error))
            self.result_label.setText("")

    def creating_polygon(self):
        layer = self.layer_MapLayer.currentLayer()
        selected_features2 = layer.selectedFeatures()
        
        if len(selected_features2) >= 3:
            list_xy_coordinates_poli = []

            for feature in selected_features2:
                point_attributes = feature.attributes()
                x_coordinate_poli = point_attributes[0]
                y_coordinate_poli = point_attributes[1]
                list_xy_coordinates_poli.append([x_coordinate_poli, y_coordinate_poli])

            polygon_points = [QgsPointXY(x, y) for x, y in list_xy_coordinates_poli]
            polygon_geometry = QgsGeometry.fromPolygonXY([polygon_points])

            crs = QgsProject.instance().crs().authid()
            layer1 = QgsVectorLayer("Polygon?crs=" + crs, "Polygon", "memory")
            provider = layer1.dataProvider()

            # Dodaj atrybut 'area' do definicji pól warstwy
            provider.addAttributes([QgsField('area', QVariant.Double)])

            layer1.updateFields()  # Zaktualizuj pola warstwy

            feature = QgsFeature()
            feature.setGeometry(polygon_geometry)
            feature.setAttributes([self.final_area])  # Ustaw wartość atrybutu 'area'

            provider.addFeature(feature)  # Dodaj obiekt feature do warstwy
            layer1.updateExtents()

            QgsProject.instance().addMapLayer(layer1)

            canvas = QgsMapCanvas()
            canvas.setCanvasColor(Qt.white)
            canvas.setLayers([layer1])
            canvas.zoomToFullExtent()
            canvas.show()

    def setHiddenFalse(self):
        self.groupBox_choose_zone.setHidden(False)
        self.label.setHidden(False)

    def setHiddenTrue(self):
        self.checkBox_zone_5.setChecked(False)
        self.checkBox_zone_6.setChecked(False)
        self.checkBox_zone_7.setChecked(False)
        self.checkBox_zone_8.setChecked(False)
        self.groupBox_choose_zone.setHidden(True)
        self.label.setHidden(True)

    def add_layer_with_coordinates_from_file(self):
        file_path = self.sciezka.filePath()  # Ścieżka do pliku z danymi

            # Tworzenie warstwy tymczasowej w pamięci
        
        EPSG = ""

        if self.radioButton_1992.isChecked():
            EPSG = "Point?crs=EPSG:2180"
        elif self.radioButton_2000.isChecked():
            self.label.setVisible(True)
            if self.checkBox_zone_5.isChecked():
                EPSG = "Point?crs=EPSG:2176"
            elif self.checkBox_zone_6.isChecked():
                EPSG = "Point?crs=EPSG:2177"
            elif self.checkBox_zone_7.isChecked():
                EPSG = "Point?crs=EPSG:2178"
            elif self.checkBox_zone_8.isChecked():
                EPSG = "Point?crs=EPSG:2179"

        nazwa_warstwa = self.newlayer_lineEdit.text()

        warstwa = QgsVectorLayer(EPSG, nazwa_warstwa, "memory")
        provider = warstwa.dataProvider()

        # Dodawanie pól do warstwy
        provider.addAttributes([QgsField("x", QVariant.Double)])
        provider.addAttributes([QgsField("y", QVariant.Double)])
        provider.addAttributes([QgsField("z", QVariant.Double)])
        warstwa.updateFields()

        # Otwieranie pliku i odczytywanie wartości
        with open(file_path, 'r') as file:
            for line in file:
                # Przetwarzanie linii i pobieranie wartości
                line = line.strip()
                values = line.split(";")
                x = float(values[0])
                y = float(values[1])
                z = float(values[2])

                # Tworzenie geometrii punktu
                punkt = QgsPointXY(x, y)
                geometria = QgsGeometry.fromPointXY(punkt)

                # Tworzenie nowej funkcji z geometrią i wartościami
                funkcja = QgsFeature()
                funkcja.setGeometry(geometria)
                funkcja.setAttributes([x, y, z])

                # Dodawanie funkcji do warstwy
                provider.addFeatures([funkcja])

        # Aktualizowanie zakresu warstwy
        warstwa.updateExtents()

        # Dodawanie warstwy do projektu
        QgsProject.instance().addMapLayer(warstwa)

        # Odświeżanie widoku mapy
        iface.mapCanvas().refresh()

    def claer(self):
        self.result_label.setText("")
        layer = self.layer_MapLayer.currentLayer()
        if layer is not None:
            layer.removeSelection()