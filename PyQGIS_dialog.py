# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PyQGISDialog
                                 A QGIS plugin
 This plugin gives diffrence between points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by SH,JB
        email                : Votum1103@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from unittest import result
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import Qt
from qgis.PyQt import uic, QtWidgets
from qgis.core import Qgis, QgsFeature, QgsGeometry, QgsVectorLayer, QgsProject, QgsPointXY, QgsField, QgsFields, QgsMapLayerModel
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
from qgis.gui import QgsMapCanvas
from PyQt5.QtWidgets import QButtonGroup
from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView
from PyQt5.QtGui import QPixmap
import math as math
from qgis.core import QgsPoint
import numpy as np 


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'PyQGIS_dialog_base.ui'))


class PyQGISDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        super(PyQGISDialog, self).__init__(parent)
        self.setupUi(self)

        final_area = None

        filters = ['Pliki tekstowe (*.txt)', 'Pliki CSV (*.csv)']
        filter_string = ';;'.join(filters)
        self.sciezka.setFilter(filter_string)

        self.checkBox_poligon.setHidden(True)
        self.groupBox_choose_zone.setHidden(True)
        self.label.setVisible(False)
        
        self.button_group = QtWidgets.QButtonGroup()
        self.button_group.addButton(self.height_radioButton)
        self.button_group.addButton(self.area_radioButton)
        self.comboBox_jednostki.setHidden(True)

        self.buttonbox_group = QButtonGroup()
        self.buttonbox_group.addButton(self.checkBox_zone_5)
        self.buttonbox_group.addButton(self.checkBox_zone_6)
        self.buttonbox_group.addButton(self.checkBox_zone_7)
        self.buttonbox_group.addButton(self.checkBox_zone_8)

        self.height_radioButton.toggled.connect(self.on_radio_button_height_toggled)
        self.area_radioButton.toggled.connect(self.on_radio_button_area_toggled)
        self.calculate_Button.clicked.connect(self.on_calculate_button_clicked)
        self.pushButton_add_layer.clicked.connect(self.add_layer_with_coordinates_from_file)
        self.radioButton_2000.toggled.connect(self.setHiddenFalse)
        self.radioButton_1992.toggled.connect(self.setHiddenTrue)
        self.pushButton_clear.clicked.connect(self.claer)

    def display_message(self, message):
        iface.messageBar().pushMessage("Informacja", message, level=Qgis.Info)

    def on_radio_button_height_toggled(self):
        if self.height_radioButton.isChecked():
            self.area_radioButton.setChecked(False)
            self.checkBox_poligon.setHidden(True) 
            self.checkBox_poligon.setChecked(False)
            self.comboBox_jednostki.setHidden(True)
            self.result_label.setText("")
            

    def on_radio_button_area_toggled(self):
        if self.area_radioButton.isChecked():
            self.height_radioButton.setChecked(False)
            self.checkBox_poligon.setEnabled(True)
            self.checkBox_poligon.setHidden(False)
            self.comboBox_jednostki.setHidden(False)
            self.result_label.setText("")

    def on_calculate_button_clicked(self):
        if self.height_radioButton.isChecked():
            self.get_height_between_two_points()
        elif self.area_radioButton.isChecked():
            self.get_area_between_points()
            if self.checkBox_poligon.isChecked():
                self.creating_polygon()

    def get_height_between_two_points(self):
        layer = self.layer_MapLayer.currentLayer()
        selected_features = layer.selectedFeatures()
        if len(selected_features) == 2:
            list_with_height = []
            features_id = []

            for feature in selected_features:
                point_attributes = feature.attributes()
                attribute_value = point_attributes[2]
                feature_id = feature.id()
                features_id.append(feature_id)
                list_with_height.append(attribute_value)

            height_difference = abs(list_with_height[1] - list_with_height[0])
            self.result_label.setText(str(height_difference)+" m")
            self.errors_label.setText("")
            self.display_message(f"Różnica wysokości między punktami o numerach {features_id[0]},{features_id[1]} wynosi: {height_difference} [m]")
        else:
            self.errors_label.setText("Niepoprawna ilość wybranych punktów. Wybierz 2 punkty.")
            self.result_label.setText("")
            
    def get_area_between_points(self):
        layer_area = self.layer_MapLayer.currentLayer()
        selected_features_area = layer_area.selectedFeatures()
        if len(selected_features_area) >= 3:
    
            points = [feature.geometry().asPoint() for feature in selected_features_area]
            centroid = QgsPoint(sum(point.x() for point in points) / len(points),
                            sum(point.y() for point in points) / len(points))
            points.sort(key=lambda point: -math.atan2(point.y() - centroid.y(), point.x() - centroid.x()))
            results = 0.5 * np.abs(
            sum(points[i - 1].x() * points[i].y() - points[i].x() * points[i - 1].y() for i in range(len(points))))

            area_features_id= []

            for feature in selected_features_area:
                feature_id = feature.id()
                area_features_id.append(feature_id)
                
            if self.comboBox_jednostki.currentText() == "m2":
                results = results
            elif self.comboBox_jednostki.currentText() == "a":
                results = results/100
            elif self.comboBox_jednostki.currentText() == "ha":
                results = results/10000

            result_area = f"{results:.3f}"
            self.result_label.setText(str(result_area))
            self.errors_label.setText("")
            self.final_area = results
            self.display_message(f"Pole powierzchni figury o wierzchołkach w punktach o numerach: {area_features_id} wynosi: {results} {self.comboBox_jednostki.currentText()}")
        else:
            error = "Niepoprawna ilość wybranych punktów. Wybierz więcej niż 2 punkty"
            self.errors_label.setText(str(error))
            self.result_label.setText("")

    def creating_polygon(self):
        canvas = iface.mapCanvas()
        layer = self.layer_MapLayer.currentLayer()
        crs = layer.crs()
        crs_authid = crs.authid() if crs else ''
        selected_features = layer.selectedFeatures()
        if len(selected_features) < 3:
            iface.messageBar().pushMessage("Błąd",
                                        "Wybierz co najmniej 3 punkty do narysowania poligonu.",
                                        level=Qgis.Warning)
            return
        points = [feature.geometry().asPoint() for feature in selected_features]
        centroid = QgsPoint(sum(point.x() for point in points) / len(points),
                            sum(point.y() for point in points) / len(points))
        points.sort(key=lambda point: -math.atan2(point.y() - centroid.y(), point.x() - centroid.x()))
        new_layer = QgsVectorLayer("Polygon?crs=" + crs_authid, "Poligon", "memory")
        provider = new_layer.dataProvider()
        provider.addAttributes([QgsField('area', QVariant.Double)])  # Add the 'area' attribute
        new_layer.startEditing()
        poly_feature = QgsFeature()
        polygon = QgsGeometry.fromPolygonXY([points])
        poly_feature.setGeometry(polygon)
        new_layer.commitChanges()
        QgsProject.instance().addMapLayer(new_layer)
        canvas.refresh()

        polygon = QgsGeometry.fromPolygonXY([points])
        feature = QgsFeature()
        feature.setGeometry(polygon)

        if self.final_area != "":
            area_value = float(self.final_area)
            feature.setAttributes([area_value])

        provider.addFeatures([feature])
        new_layer.updateExtents()
        QgsProject.instance().addMapLayer(new_layer)


    def setHiddenFalse(self):
        self.groupBox_choose_zone.setHidden(False)
        self.label.setHidden(False)

    def setHiddenTrue(self):
        self.checkBox_zone_5.setChecked(False)
        self.checkBox_zone_6.setChecked(False)
        self.checkBox_zone_7.setChecked(False)
        self.checkBox_zone_8.setChecked(False)
        self.groupBox_choose_zone.setHidden(True)
        self.label.setHidden(True)

    def add_layer_with_coordinates_from_file(self):
        file_path = self.sciezka.filePath()  # Ścieżka do pliku z danymi

            # Tworzenie warstwy tymczasowej w pamięci
        
        EPSG = ""

        if self.radioButton_1992.isChecked():
            EPSG = "Point?crs=EPSG:2180"
        elif self.radioButton_2000.isChecked():
            self.label.setVisible(True)
            if self.checkBox_zone_5.isChecked():
                EPSG = "Point?crs=EPSG:2176"
            elif self.checkBox_zone_6.isChecked():
                EPSG = "Point?crs=EPSG:2177"
            elif self.checkBox_zone_7.isChecked():
                EPSG = "Point?crs=EPSG:2178"
            elif self.checkBox_zone_8.isChecked():
                EPSG = "Point?crs=EPSG:2179"

        nazwa_warstwa = self.newlayer_lineEdit.text()

        warstwa = QgsVectorLayer(EPSG, nazwa_warstwa, "memory")
        provider = warstwa.dataProvider()

        # Dodawanie pól do warstwy
        provider.addAttributes([QgsField("x", QVariant.Double)])
        provider.addAttributes([QgsField("y", QVariant.Double)])
        provider.addAttributes([QgsField("z", QVariant.Double)])
        warstwa.updateFields()

        # Otwieranie pliku i odczytywanie wartości
        with open(file_path, 'r') as file:
            for line in file:
                # Przetwarzanie linii i pobieranie wartości
                line = line.strip()
                values = line.split(";")
                x = float(values[0])
                y = float(values[1])
                z = float(values[2])

                # Tworzenie geometrii punktu
                punkt = QgsPointXY(x, y)
                geometria = QgsGeometry.fromPointXY(punkt)

                # Tworzenie nowej funkcji z geometrią i wartościami
                funkcja = QgsFeature()
                funkcja.setGeometry(geometria)
                funkcja.setAttributes([x, y, z])

                # Dodawanie funkcji do warstwy
                provider.addFeatures([funkcja])

        # Aktualizowanie zakresu warstwy
        warstwa.updateExtents()

        # Dodawanie warstwy do projektu
        QgsProject.instance().addMapLayer(warstwa)

        # Odświeżanie widoku mapy
        iface.mapCanvas().refresh()

    def claer(self):
        self.result_label.setText("")
        layer = self.layer_MapLayer.currentLayer()
        if layer is not None:
            layer.removeSelection()
